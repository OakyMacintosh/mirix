#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mnc_parser.h"
#include "mnc_compiler.h"

// Test M&C code (from README)
const char* test_code = 
    "%sys $mirix*032$ "
    "// define system "
    "%typosis $mmm.lib*0xf08$ "
    "// import stdlib "
    "$$start* @mkdef "
    "char* { "
    "// define chars "
    "str: \"h\" & 0x01; "
    "str: \"e\" & 0x10; "
    "str: \"l\" & 0x11 * 2: "
    "str: \"e\" & 0x100; "
    "str: \"w\" & 0x101; "
    "str: \"d\" & 0x110; "
    "str: \"o\" & 0x111; "
    "str: \"r\" & 0x1000; "
    "}; "
    "%%ascii %$mk & addrlst: 0x01, 0x10, 0x11*2, 0x100, $$blk, 0x101, 0x110, 0x1000, 0x11, 0x110; "
    "&&prtlist addrlst "
    "%return cnil";

// Print AST (simple recursive function)
static void print_ast(ast_node_t *node, int depth) {
    if (!node) return;
    
    // Print indentation
    for (int i = 0; i < depth; i++) printf("  ");
    
    // Print node info
    const char *type_str;
    switch (node->type) {
        case NODE_PROGRAM: type_str = "PROGRAM"; break;
        case NODE_SYS_DECL: type_str = "SYS_DECL"; break;
        case NODE_IMPORT: type_str = "IMPORT"; break;
        case NODE_FUNCTION: type_str = "FUNCTION"; break;
        case NODE_VARIABLE: type_str = "VARIABLE"; break;
        case NODE_STRING: type_str = "STRING"; break;
        case NODE_NUMBER: type_str = "NUMBER"; break;
        case NODE_IDENTIFIER: type_str = "IDENTIFIER"; break;
        case NODE_BINARY_OP: type_str = "BINARY_OP"; break;
        case NODE_CALL: type_str = "CALL"; break;
        case NODE_RETURN: type_str = "RETURN"; break;
        default: type_str = "UNKNOWN"; break;
    }
    
    printf("%s", type_str);
    if (node->value) {
        printf(": \"%s\"", node->value);
    }
    printf("\n");
    
    // Print children
    for (int i = 0; i < node->child_count; i++) {
        print_ast(node->children[i], depth + 1);
    }
}

// Print bytecode in hex
static void print_bytecode(uint8_t *bytecode, size_t size) {
    printf("Generated Bytecode:\n");
    printf("==================\n");
    
    for (size_t i = 0; i < size; i++) {
        if (i % 16 == 0) {
            printf("%08X: ", (unsigned int)i);
        }
        printf("%02X ", bytecode[i]);
        
        if (i % 16 == 15 || i == size - 1) {
            printf("\n");
        }
    }
    printf("\n");
}

int main(int argc, char **argv) {
    printf("M&C Language Parser and Compiler Test\n");
    printf("=====================================\n\n");
    
    printf("Input M&C Code:\n");
    printf("---------------\n");
    printf("%s\n\n", test_code);
    
    // Initialize parser
    mnc_parser_t *parser = mnc_parser_init(test_code);
    if (!parser) {
        fprintf(stderr, "Failed to initialize parser\n");
        return 1;
    }
    
    // Parse the code
    printf("Parsing M&C code...\n");
    int parse_result = mnc_parse(parser);
    
    if (parse_result != 0) {
        fprintf(stderr, "Parsing failed\n");
        mnc_parser_cleanup(parser);
        return 1;
    }
    
    printf("Parsing completed successfully\n\n");
    
    // Get and print AST
    ast_node_t *ast = mnc_get_ast(parser);
    if (ast) {
        printf("Abstract Syntax Tree:\n");
        printf("====================\n");
        print_ast(ast, 0);
        printf("\n");
    }
    
    // Initialize compiler
    mnc_compiler_t *compiler = mnc_compiler_init();
    if (!compiler) {
        fprintf(stderr, "Failed to initialize compiler\n");
        mnc_parser_cleanup(parser);
        return 1;
    }
    
    // Compile AST to bytecode
    printf("Compiling AST to bytecode...\n");
    int compile_result = mnc_compile(compiler, ast);
    
    if (compile_result != 0) {
        fprintf(stderr, "Compilation failed\n");
        mnc_compiler_cleanup(compiler);
        mnc_parser_cleanup(parser);
        return 1;
    }
    
    // Get and print bytecode
    size_t bytecode_size;
    uint8_t *bytecode = mnc_get_bytecode(compiler, &bytecode_size);
    if (bytecode) {
        print_bytecode(bytecode, bytecode_size);
    }
    
    // Print symbol table
    mnc_print_symbol_table(compiler);
    
    // Cleanup
    mnc_compiler_cleanup(compiler);
    mnc_parser_cleanup(parser);
    
    printf("Test completed successfully!\n");
    return 0;
}
